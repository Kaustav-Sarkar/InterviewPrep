# Deque (Double-Ended Queue)

## Quick Definition

Linear data structure supporting insertion and deletion at both ends (front and rear). Combines benefits of stack and queue operations.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| AddFirst/Last | **O(1)** | O(n) |
| RemoveFirst/Last | **O(1)** | — |
| PeekFirst/Last | **O(1)** | — |
| Search | O(n) | — |

## Core Operations

```java
// Multiple deque implementations
ArrayDeque<Integer> deque1 = new ArrayDeque<>();           // preferred, resizable array
LinkedList<Integer> deque2 = new LinkedList<>();           // doubly-linked implementation
Deque<String> deque3 = new ArrayDeque<>(Arrays.asList("a", "b", "c"));

// Both-end operations
deque1.addFirst(10);  deque1.addLast(20);     // [10, 20]
deque1.offerFirst(5); deque1.offerLast(30);   // [5, 10, 20, 30]

int first = deque1.removeFirst();    // remove and return: 5, deque: [10, 20, 30]
int last = deque1.removeLast();      // remove and return: 30, deque: [10, 20]
// Alternative: pollFirst(), pollLast() (return null if empty)

// Peek operations (non-destructive)
int peekFirst = deque1.peekFirst();  // 10 (doesn't remove)
int peekLast = deque1.peekLast();    // 20 (doesn't remove)

// Use as Stack (LIFO) - operations at one end
Deque<String> stack = new ArrayDeque<>();
stack.push("first");  stack.push("second");   // [first, second] (second on top)
String top = stack.pop();  // "second", stack: [first]

// Use as Queue (FIFO) - operations at different ends  
Deque<String> queue = new ArrayDeque<>();
queue.offer("task1"); queue.offer("task2");   // [task1, task2]
String next = queue.poll();  // "task1", queue: [task2]

// Sliding window maximum pattern (monotonic deque)
int[] nums = {1, 3, -1, -3, 5, 3, 6, 7};
int k = 3;
Deque<Integer> window = new ArrayDeque<>();  // stores indices
List<Integer> result = new ArrayList<>();

for (int i = 0; i < nums.length; i++) {
    // Remove indices outside window
    while (!window.isEmpty() && window.peekFirst() <= i - k) {
        window.pollFirst();
    }
    // Remove smaller elements (maintain decreasing order)
    while (!window.isEmpty() && nums[window.peekLast()] <= nums[i]) {
        window.pollLast();
    }
    window.offerLast(i);
    if (i >= k - 1) result.add(nums[window.peekFirst()]);  // window maximum
}
```

## Python Snippet

```python
from collections import deque

# Basic deque usage
dq = deque(["a", "b", "c"])    # init
dq.appendleft("x"); dq.append("y") # [x, a, b, c, y]
first = dq.popleft(); last = dq.pop()
peek_first, peek_last = dq[0], dq[-1]

# Monotonic deque for sliding window maximum
def max_sliding_window(nums, k):
    dq, out = deque(), []  # store indices
    for i, num in enumerate(nums):
        while dq and dq[0] <= i - k:
            dq.popleft()
        while dq and nums[dq[-1]] <= num:
            dq.pop()
        dq.append(i)
        if i >= k - 1:
            out.append(nums[dq[0]])
    return out
```

## When to Use

- Sliding window algorithms (maximum/minimum in windows)
- Implementing stacks and queues with single data structure
- Palindrome checking with two-pointer approach
- Browser history (back/forward with limited memory)
- Task scheduling with priority insertion at both ends

## Trade-offs

**Pros:**

- O(1) operations at both ends
- Versatile - can function as stack, queue, or both
- Excellent for sliding window problems
- ArrayDeque has better cache locality than LinkedList

**Cons:**

- O(n) access to middle elements
- Slightly more complex than single-ended structures
- Memory overhead in linked implementations
- Not as intuitive as specialized stack/queue

## Practice Problems

- **Sliding Window Maximum**: Use monotonic deque to track maximum in each window
- **Valid Palindrome**: Two pointers from both ends using deque
- **Implement Stack and Queue**: Use single deque for both operations
- **Shortest Subarray with Sum at Least K**: Monotonic deque optimization
- **Design Circular Deque**: Implement with fixed-size array

<details>
<summary>Implementation Notes (Advanced)</summary>

### Implementation Choices

- **ArrayDeque**: Circular array, preferred for performance
- **LinkedList**: Doubly-linked nodes, implements Deque interface
- **Custom circular buffer**: Fixed-size for memory-constrained environments

### ArrayDeque Internals

- **Circular array**: Head and tail pointers wrap around
- **Growth strategy**: Doubles capacity when full, reorders elements
- **Initial capacity**: 16 elements, grows as needed

### Performance Characteristics

- **Cache locality**: ArrayDeque superior due to array-based storage
- **Memory overhead**: ArrayDeque ~25-50%, LinkedList ~200%
- **Thread safety**: Neither ArrayDeque nor LinkedList are thread-safe

### Monotonic Deque Pattern

- **Increasing**: Remove larger elements from rear before insertion
- **Decreasing**: Remove smaller elements from rear before insertion
- **Window management**: Remove elements outside current window from front

### Design Patterns

- **Adapter pattern**: Single deque implementing multiple interfaces
- **Strategy pattern**: Choose implementation based on access patterns

</details>
