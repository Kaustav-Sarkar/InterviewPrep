# Queue

## Quick Definition

FIFO (First In, First Out) data structure where elements are added at rear and removed from front. Think of a waiting line.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| Enqueue   | **O(1)** | O(n) |
| Dequeue   | **O(1)** | — |
| Front/Peek| **O(1)** | — |
| Search    | O(n) | — |

## Core Operations

```java
// Multiple implementation options
LinkedList<Integer> queue1 = new LinkedList<>();     // implements Queue
ArrayDeque<Integer> queue2 = new ArrayDeque<>();     // preferred, resizable
PriorityQueue<Integer> queue3 = new PriorityQueue<>(); // heap-based priority queue

// Enqueue (add to rear)
queue2.offer(10); queue2.offer(20); queue2.offer(30);
// Alternative: queue2.add(), queue2.addLast()

// Dequeue (remove from front)  
int front = queue2.poll();           // removes and returns: 10
int peek = queue2.peek();            // returns without removing: 20
// Alternative: queue2.remove(), queue2.removeFirst()

// Check state
boolean empty = queue2.isEmpty();
int size = queue2.size();

// Multiple element operations
queue2.addAll(Arrays.asList(40, 50, 60));
while (!queue2.isEmpty()) {
    System.out.println(queue2.poll());  // print in FIFO order
}

// BFS traversal pattern
Queue<TreeNode> bfsQueue = new LinkedList<>();
bfsQueue.offer(root);
while (!bfsQueue.isEmpty()) {
    int levelSize = bfsQueue.size();
    for (int i = 0; i < levelSize; i++) {
        TreeNode node = bfsQueue.poll();
        process(node);
        if (node.left != null) bfsQueue.offer(node.left);
        if (node.right != null) bfsQueue.offer(node.right);
    }
}

// Producer-Consumer pattern
BlockingQueue<String> taskQueue = new LinkedBlockingQueue<>();
// Producer: taskQueue.put(task);
// Consumer: String task = taskQueue.take();
```

## Python Snippet

```python
from collections import deque
from queue import Queue

# Multiple implementations
q1 = deque()           # preferred
q2 = Queue()           # thread-safe

# Enqueue / Dequeue
q1.append(10); q1.append(20); q1.append(30)
front = q1.popleft()   # 10
peek = q1[0]           # 20

# BFS pattern
def bfs(graph, start):
    seen, dq = {start}, deque([start])
    order = []
    while dq:
        u = dq.popleft(); order.append(u)
        for v in graph.get(u, []):
            if v not in seen:
                seen.add(v); dq.append(v)
    return order
```

## When to Use

- BFS algorithms and level-order tree traversal
- Task scheduling and job processing systems
- Producer-consumer patterns and buffering
- Rate limiting and request throttling mechanisms
- Printer spooling and resource management

## Trade-offs

**Pros:**

- O(1) enqueue and dequeue operations
- Natural FIFO ordering for fair processing
- Essential for BFS and level-order algorithms
- Good for streaming data and pipeline processing

**Cons:**

- No random access to middle elements
- Limited to FIFO access pattern only
- Search requires linear traversal
- Memory overhead for linked implementations

## Practice Problems

- **Queue using Stacks**: Implement queue using two stacks
- **Sliding Window Maximum**: Find maximum in each window using deque
- **Binary Tree Level Order**: BFS traversal returning level-by-level results
- **Rotting Oranges**: Multi-source BFS for grid problems
- **Moving Average**: Calculate average of last k elements in stream

<details>
<summary>Implementation Notes (Advanced)</summary>

### Implementation Choices

- **ArrayDeque**: Preferred for most use cases, resizable circular array
- **LinkedList**: Good for frequent size changes, implements both Queue and Deque
- **PriorityQueue**: Heap-based, for priority ordering instead of FIFO
- **BlockingQueue**: Thread-safe variants for concurrent applications

### Memory Characteristics

- **ArrayDeque**: Circular array, 2x growth, better cache locality
- **LinkedList**: Doubly-linked nodes, pointer overhead but flexible
- **Memory overhead**: ArrayDeque ~25-50%, LinkedList ~200% (pointers)

### Performance Considerations

- **Cache performance**: Array-based implementations outperform linked
- **Thread safety**: Most implementations are not thread-safe by default
- **Blocking variants**: LinkedBlockingQueue, ArrayBlockingQueue for producers/consumers

### Queue Variants

- **Deque**: Double-ended queue, supports both ends operations
- **Priority Queue**: Elements dequeued by priority, not FIFO order
- **Circular Queue**: Fixed-size array-based, prevents memory waste
- **Blocking Queue**: Thread-safe with blocking put/take operations

</details>
