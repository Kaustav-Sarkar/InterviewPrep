# Graph Adjacency List

## Quick Definition

Graph representation where each vertex stores a list of its adjacent vertices. Space-efficient for sparse graphs, enabling fast iteration over neighbors.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| Add Vertex | **O(1)** | O(V + E) |
| Add Edge | **O(1)** | — |
| Remove Edge | O(degree) | — |
| Check Edge | O(degree) | — |
| Get Neighbors | **O(1)** | — |

## Core Operations

```java
// List-based adjacency representation
class GraphAdjList {
    private int vertices;
    private List<List<Integer>> adjList;
    
    public GraphAdjList(int vertices) {
        this.vertices = vertices;
        adjList = new ArrayList<>(vertices);
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList<>());
        }
    }
    
    // Add directed edge
    public void addEdge(int from, int to) {
        adjList.get(from).add(to);
    }
    
    // Add undirected edge
    public void addUndirectedEdge(int u, int v) {
        adjList.get(u).add(v);
        adjList.get(v).add(u);
    }
    
    // Get neighbors
    public List<Integer> getNeighbors(int vertex) {
        return adjList.get(vertex);
    }
}

// Map-based adjacency (dynamic vertices)
Map<Integer, List<Integer>> graph = new HashMap<>();
graph.put(1, new ArrayList<>(Arrays.asList(2, 3)));
graph.put(2, new ArrayList<>(Arrays.asList(4)));
graph.put(3, new ArrayList<>(Arrays.asList(4, 5)));

// Weighted graph with custom Edge class
class Edge {
    int to, weight;
    Edge(int to, int weight) { this.to = to; this.weight = weight; }
}

Map<Integer, List<Edge>> weightedGraph = new HashMap<>();
weightedGraph.put(1, Arrays.asList(new Edge(2, 10), new Edge(3, 5)));

// BFS traversal pattern
void bfs(Map<Integer, List<Integer>> graph, int start) {
    Set<Integer> visited = new HashSet<>();
    Queue<Integer> queue = new LinkedList<>();
    
    queue.offer(start);
    visited.add(start);
    
    while (!queue.isEmpty()) {
        int current = queue.poll();
        System.out.print(current + " ");
        
        for (int neighbor : graph.getOrDefault(current, Collections.emptyList())) {
            if (!visited.contains(neighbor)) {
                visited.add(neighbor);
                queue.offer(neighbor);
            }
        }
    }
}

// DFS traversal pattern
void dfs(Map<Integer, List<Integer>> graph, int vertex, Set<Integer> visited) {
    visited.add(vertex);
    System.out.print(vertex + " ");
    
    for (int neighbor : graph.getOrDefault(vertex, Collections.emptyList())) {
        if (!visited.contains(neighbor)) {
            dfs(graph, neighbor, visited);
        }
    }
}

// Dijkstra's shortest path
Map<Integer, Integer> dijkstra(Map<Integer, List<Edge>> graph, int start) {
    Map<Integer, Integer> distances = new HashMap<>();
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]); // [vertex, distance]
    
    distances.put(start, 0);
    pq.offer(new int[]{start, 0});
    
    while (!pq.isEmpty()) {
        int[] current = pq.poll();
        int vertex = current[0], dist = current[1];
        
        if (dist > distances.getOrDefault(vertex, Integer.MAX_VALUE)) continue;
        
        for (Edge edge : graph.getOrDefault(vertex, Collections.emptyList())) {
            int newDist = dist + edge.weight;
            if (newDist < distances.getOrDefault(edge.to, Integer.MAX_VALUE)) {
                distances.put(edge.to, newDist);
                pq.offer(new int[]{edge.to, newDist});
            }
        }
    }
    return distances;
}
```

## Python Snippet

```python
from collections import defaultdict, deque

# List-based adjacency
class GraphAdjList:
    def __init__(self, n):
        self.n = n
        self.adj = [[] for _ in range(n)]
    def add_edge(self, u, v):
        self.adj[u].append(v)
    def add_undirected(self, u, v):
        self.adj[u].append(v); self.adj[v].append(u)
    def neighbors(self, u):
        return self.adj[u]

# Map-based adjacency (dynamic)
graph = defaultdict(list)
graph[1] += [2, 3]
graph[2] += [4]
graph[3] += [4, 5]

# BFS / DFS
def bfs(graph, start):
    seen, q = {start}, deque([start])
    order = []
    while q:
        u = q.popleft(); order.append(u)
        for v in graph.get(u, []):
            if v not in seen:
                seen.add(v); q.append(v)
    return order

def dfs(graph, u, seen=None, out=None):
    if seen is None: seen = set()
    if out is None: out = []
    seen.add(u); out.append(u)
    for v in graph.get(u, []):
        if v not in seen:
            dfs(graph, v, seen, out)
    return out

# Dijkstra (adj list with (to, w))
import heapq
def dijkstra(adj, start):
    dist = defaultdict(lambda: float('inf'))
    dist[start] = 0
    pq = [(0, start)]
    while pq:
        d, u = heapq.heappop(pq)
        if d != dist[u]:
            continue
        for v, w in adj.get(u, []):
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                heapq.heappush(pq, (nd, v))
    return dist
```

## When to Use

- Social networks (friends, followers, connections)
- Web page link analysis and search engines
- Route planning and GPS navigation systems
- Dependency graphs in build systems and package managers
- Circuit design and network topology analysis

## Trade-offs

**Pros:**

- Space-efficient for sparse graphs O(V + E)
- Fast neighbor iteration
- Dynamic - easy to add/remove vertices
- Efficient for graph traversal algorithms (BFS, DFS)

**Cons:**

- Checking edge existence is O(degree)
- Poor cache locality due to pointer indirection
- Memory overhead for storing lists/pointers
- Difficult to parallelize some operations

## Practice Problems

- **Clone Graph**: Deep copy graph using DFS/BFS
- **Course Schedule**: Detect cycles using topological sort
- **Number of Islands**: Connected components in grid
- **Word Ladder**: Shortest transformation path using BFS
- **Alien Dictionary**: Topological sort of character dependencies

<details>
<summary>Implementation Notes (Advanced)</summary>

### Space Complexity Analysis

- **Directed graph**: O(V + E) where E is number of edges
- **Undirected graph**: O(V + 2E) since each edge stored twice
- **Dense graph**: Can approach O(V²) but still better than adjacency matrix

### Implementation Variants

- **ArrayList**: Fast random access, good for static graphs
- **LinkedList**: Fast insertion/deletion, good for dynamic graphs
- **HashSet**: O(1) edge checking, higher memory overhead
- **TreeSet**: Sorted neighbors, O(log degree) operations

### Performance Characteristics

- **Cache locality**: Poor due to list traversal and pointer chasing
- **Memory allocation**: Many small allocations can fragment heap
- **Traversal efficiency**: Excellent for BFS/DFS and pathfinding

### Optimization Techniques

- **Compact representation**: Use arrays instead of lists for static graphs
- **Edge bundling**: Group multiple edges to same destination
- **Lazy deletion**: Mark edges as deleted instead of immediate removal

### Graph Algorithm Suitability

- **BFS/DFS**: Excellent - natural neighbor iteration
- **Shortest path**: Good for Dijkstra, Bellman-Ford
- **MST**: Good for Kruskal (with edge list), Prim
- **Flow algorithms**: Adequate but may need reverse edge handling

</details>
