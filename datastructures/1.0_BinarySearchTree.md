# Binary Search Tree

## Quick Definition

A binary tree where left subtree contains values ≤ root, right subtree contains values > root. Maintains sorted order for efficient search operations.

## Big-O Summary

| Operation | Average | Worst | Space |
|-----------|---------|-------|-------|
| Search    | **O(log n)** | O(n) | O(n) |
| Insert    | **O(log n)** | O(n) | — |
| Delete    | **O(log n)** | O(n) | — |
| Traversal | O(n) | O(n) | O(h)* |
*h = height for recursion stack

## Core Operations

```java
// TreeSet (sorted set implementation)
TreeSet<Integer> bst1 = new TreeSet<>();
TreeSet<Integer> bst2 = new TreeSet<>(Arrays.asList(5, 3, 7, 1, 9));
TreeSet<Integer> bst3 = new TreeSet<>(Collections.reverseOrder()); // descending

// TreeMap (sorted key-value pairs)
TreeMap<Integer, String> map = new TreeMap<>();
TreeMap<String, Integer> wordCount = new TreeMap<>();

// Basic operations
bst1.add(5); bst1.add(3); bst1.add(7);     // insert
boolean found = bst1.contains(5);          // search: O(log n)
bst1.remove(3);                            // delete: O(log n)

// Range operations (BST advantage)
Integer lower = bst2.floor(6);             // largest ≤ 6
Integer higher = bst2.ceiling(6);          // smallest ≥ 6
NavigableSet<Integer> range = bst2.subSet(3, true, 8, false); // [3,8)

// Ordered traversals
for (int val : bst2) System.out.print(val + " ");           // inorder (sorted)
bst2.descendingSet().forEach(System.out::println);          // reverse order

// Custom node implementation
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}
```

## Python Snippet

```python
class Node:
    def __init__(self, val):
        self.val = val; self.left = None; self.right = None

def insert(root, val):
    if not root: return Node(val)
    if val < root.val:
        root.left = insert(root.left, val)
    elif val > root.val:
        root.right = insert(root.right, val)
    return root

def search(root, val):
    cur = root
    while cur and cur.val != val:
        cur = cur.left if val < cur.val else cur.right
    return cur is not None

def inorder(root, out):
    if root:
        inorder(root.left, out); out.append(root.val); inorder(root.right, out)
```

## When to Use

- Maintain sorted collection with frequent insertions/deletions
- Range queries (find all elements between x and y)
- Order statistics (kth smallest/largest element)
- Database indexing and B-tree variants
- Symbol tables in compilers and interpreters

## Trade-offs

**Pros:**

- O(log n) search, insert, delete (balanced trees)
- Maintains sorted order automatically
- Efficient range queries and order statistics
- Memory-efficient compared to sorted arrays for dynamic data

**Cons:**

- O(n) worst-case for unbalanced trees (becomes linked list)
- Higher memory overhead than arrays (pointer storage)
- No constant-time access by index
- Cache performance inferior to arrays for large datasets

## Practice Problems

- **Validate BST**: Check if binary tree satisfies BST property
- **Lowest Common Ancestor**: Find LCA of two nodes in BST
- **Kth Smallest in BST**: Find kth smallest element using inorder traversal
- **Convert Sorted Array to BST**: Build balanced BST from sorted array
- **Serialize/Deserialize BST**: Encode BST to string and reconstruct

<details>
<summary>Implementation Notes (Advanced)</summary>

### Self-Balancing Variants

- **AVL Trees**: Height-balanced, guarantees O(log n) operations
- **Red-Black Trees**: Used in TreeSet/TreeMap, less strict balancing
- **Splay Trees**: Self-adjusting, frequently accessed nodes move to root

### Memory Layout

- **Node overhead**: Each node stores value + 2 pointers (16-24 bytes)
- **Cache locality**: Poor compared to arrays due to random memory allocation
- **Tree height**: Balanced trees have height O(log n), unbalanced O(n)

### Traversal Algorithms

- **Inorder**: Left → Root → Right (gives sorted sequence)
- **Preorder**: Root → Left → Right (useful for serialization)
- **Postorder**: Left → Right → Root (useful for deletion)
- **Morris Traversal**: O(1) space traversal using threading

</details>
