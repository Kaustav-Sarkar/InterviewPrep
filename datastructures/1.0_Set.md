# Set

## Quick Definition

Collection that stores unique elements with no duplicates allowed. Provides fast membership testing and set operations like union/intersection.

## Big-O Summary

| Operation | Average | Worst | Space |
|-----------|---------|-------|-------|
| Add       | **O(1)** | O(n)* | O(n) |
| Remove    | **O(1)** | O(n)* | — |
| Contains  | **O(1)** | O(n)* | — |
| Iterator  | O(n) | O(n) | — |
*O(log n) for TreeSet

## Core Operations

```java
// Multiple Set implementations
HashSet<String> set1 = new HashSet<>();                    // fastest, no ordering
LinkedHashSet<String> set2 = new LinkedHashSet<>();        // insertion order
TreeSet<String> set3 = new TreeSet<>();                    // sorted order
Set<String> set4 = Set.of("a", "b", "c");                 // immutable

// Initialization options
HashSet<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
HashSet<String> words = new HashSet<>(List.of("apple", "banana", "cherry"));

// Basic operations
set1.add("hello");                     // insert element
boolean removed = set1.remove("hello"); // remove element: true
boolean contains = set1.contains("world"); // membership test: false

// Set operations
Set<Integer> setA = Set.of(1, 2, 3, 4);
Set<Integer> setB = Set.of(3, 4, 5, 6);

// Union (all elements from both sets)
Set<Integer> union = new HashSet<>(setA);
union.addAll(setB);  // {1, 2, 3, 4, 5, 6}

// Intersection (common elements)
Set<Integer> intersection = new HashSet<>(setA);
intersection.retainAll(setB);  // {3, 4}

// Difference (elements in A but not B)
Set<Integer> difference = new HashSet<>(setA);
difference.removeAll(setB);  // {1, 2}

// Iteration patterns
for (String item : set2) System.out.println(item);
set1.forEach(System.out::println);

// Duplicate detection pattern
String[] array = {"a", "b", "a", "c", "b"};
Set<String> unique = new HashSet<>();
Set<String> duplicates = new HashSet<>();
for (String item : array) {
    if (!unique.add(item)) duplicates.add(item);  // add returns false if duplicate
}
// unique: {a, b, c}, duplicates: {a, b}

// Stream operations
Set<String> filtered = set2.stream()
    .filter(s -> s.length() > 3)
    .collect(Collectors.toSet());
```

## Python Snippet

```python
# Multiple set initializations
set1 = set()
set2 = {'a', 'b', 'c'}

# Basic operations
set1.add('hello')
set1.discard('hello')      # safe remove
contains = 'world' in set1

# Set operations
A = {1, 2, 3, 4}
B = {3, 4, 5, 6}
union = A | B
intersection = A & B
difference = A - B

# Duplicate detection
arr = ['a', 'b', 'a', 'c', 'b']
seen, dups = set(), set()
for x in arr:
    if x in seen:
        dups.add(x)
    else:
        seen.add(x)
```

## When to Use

- Duplicate detection and unique element storage
- Fast membership testing (whitelists, blacklists)
- Set operations (union, intersection, difference)
- Tracking visited states in graph algorithms
- Implementing mathematical sets and relationships

## Trade-offs

**Pros:**

- O(1) average-case operations (HashSet)
- Automatic duplicate elimination
- Efficient set operations (union, intersection)
- Clean API for mathematical set operations

**Cons:**

- No indexing or positional access
- Memory overhead compared to arrays
- Hash-based sets have no ordering guarantees
- TreeSet has O(log n) operations vs O(1) for HashSet

## Practice Problems

- **Intersection of Two Arrays**: Find common elements using HashSet
- **Contains Duplicate**: Check if array has duplicates using Set.add()
- **Longest Consecutive Sequence**: Use HashSet for O(n) solution
- **Happy Number**: Track seen numbers to detect cycles
- **Word Pattern**: Use sets to track bijective mapping

<details>
<summary>Implementation Notes (Advanced)</summary>

### Set Implementations

- **HashSet**: Hash table based, O(1) operations, no ordering
- **LinkedHashSet**: Hash table + linked list, maintains insertion order
- **TreeSet**: Red-black tree, O(log n) operations, sorted order
- **EnumSet**: Bit vector for enum types, very space efficient

### Performance Characteristics

- **HashSet**: Best general-purpose performance
- **LinkedHashSet**: Predictable iteration order with slight overhead
- **TreeSet**: Sorted access but slower operations
- **Memory usage**: HashSet < LinkedHashSet < TreeSet

### Hash Function Quality

- **Load factor**: Default 0.75 for good space/time tradeoff
- **Hash collisions**: Poor hash functions degrade to O(n) operations
- **Resize cost**: O(n) rehashing when load factor exceeded

### Set Operations Complexity

- **Union**: O(n + m) where n, m are set sizes
- **Intersection**: O(min(n, m)) with proper implementation
- **Difference**: O(n) for elements in first set
- **Symmetric difference**: O(n + m) for elements in either but not both

</details>
