# Trie (Prefix Tree)

## Quick Definition

Tree-like data structure where each node represents a character, and paths from root to leaf represent complete words. Optimized for prefix-based operations.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| Insert    | **O(m)** | O(ALPHABET × n × m) |
| Search    | **O(m)** | — |
| StartsWith| **O(m)** | — |
| Delete    | O(m) | — |
*m = length of word, n = number of words*

## Core Operations

```java
// Custom Trie implementation
class TrieNode {
    TrieNode[] children = new TrieNode[26];  // for lowercase a-z
    boolean isEndOfWord = false;
    
    // Alternative: use HashMap for larger alphabets
    // Map<Character, TrieNode> children = new HashMap<>();
}

class Trie {
    private TrieNode root = new TrieNode();
    
    // Insert word into trie
    public void insert(String word) {
        TrieNode node = root;
        for (char ch : word.toCharArray()) {
            int index = ch - 'a';
            if (node.children[index] == null) {
                node.children[index] = new TrieNode();
            }
            node = node.children[index];
        }
        node.isEndOfWord = true;
    }
    
    // Search if word exists
    public boolean search(String word) {
        TrieNode node = searchNode(word);
        return node != null && node.isEndOfWord;
    }
    
    // Check if any word starts with prefix
    public boolean startsWith(String prefix) {
        return searchNode(prefix) != null;
    }
    
    private TrieNode searchNode(String str) {
        TrieNode node = root;
        for (char ch : str.toCharArray()) {
            int index = ch - 'a';
            if (node.children[index] == null) return null;
            node = node.children[index];
        }
        return node;
    }
    
    // Get all words with given prefix
    public List<String> wordsWithPrefix(String prefix) {
        List<String> result = new ArrayList<>();
        TrieNode prefixNode = searchNode(prefix);
        if (prefixNode != null) {
            dfs(prefixNode, prefix, result);
        }
        return result;
    }
    
    private void dfs(TrieNode node, String current, List<String> result) {
        if (node.isEndOfWord) result.add(current);
        for (int i = 0; i < 26; i++) {
            if (node.children[i] != null) {
                dfs(node.children[i], current + (char)('a' + i), result);
            }
        }
    }
}

// Usage example
Trie trie = new Trie();
String[] words = {"apple", "app", "apricot", "banana"};
for (String word : words) trie.insert(word);

boolean hasApp = trie.search("app");           // true
boolean hasApple = trie.search("apple");       // true  
boolean startsWithAp = trie.startsWith("ap");  // true
List<String> apWords = trie.wordsWithPrefix("ap"); // [app, apple, apricot]
```

## Python Snippet

```python
# Trie with dict children
class TrieNode:
    def __init__(self):
        self.children = {}
        self.end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    def insert(self, word):
        node = self.root
        for ch in word:
            node = node.children.setdefault(ch, TrieNode())
        node.end = True
    def search(self, word):
        node = self._walk(word)
        return bool(node and node.end)
    def starts_with(self, prefix):
        return self._walk(prefix) is not None
    def _walk(self, s):
        node = self.root
        for ch in s:
            if ch not in node.children: return None
            node = node.children[ch]
        return node
    def words_with_prefix(self, prefix):
        res, node = [], self._walk(prefix)
        def dfs(n, cur):
            if n.end: res.append(cur)
            for ch, nxt in n.children.items():
                dfs(nxt, cur + ch)
        if node: dfs(node, prefix)
        return res

# Usage
trie = Trie()
for w in ["apple", "app", "apricot", "banana"]:
    trie.insert(w)
assert trie.search("app") and trie.starts_with("ap")
```

## When to Use

- Autocomplete and search suggestions in applications
- Spell checkers and word validation systems
- IP routing tables and longest prefix matching
- Dictionary implementations with prefix queries
- DNA sequence analysis and pattern matching

## Trade-offs

**Pros:**

- O(m) search time independent of number of words
- Efficient prefix-based operations
- Space sharing for common prefixes
- Natural support for lexicographic ordering

**Cons:**

- High memory overhead (many null pointers)
- Cache performance can be poor due to pointer chasing
- Not suitable for small alphabets with few shared prefixes
- Complex deletion implementation

## Practice Problems

- **Implement Trie**: Basic insert, search, startsWith operations
- **Word Search II**: Find all words from word list in 2D board
- **Add and Search Word**: Support wildcard '.' character matching
- **Longest Word in Dictionary**: Find longest word built by other words
- **Word Break II**: Return all possible word break combinations

<details>
<summary>Implementation Notes (Advanced)</summary>

### Memory Optimization

- **Array vs HashMap**: Array faster but wastes space for sparse alphabets
- **Compressed trie**: Merge single-child nodes to reduce memory
- **Ternary Search Tree**: Alternative with better memory efficiency

### Space Complexity Analysis

- **Worst case**: O(ALPHABET_SIZE × total_characters) for no shared prefixes
- **Best case**: O(total_characters) when all words share long prefixes
- **Practical**: Depends heavily on commonality of prefixes in dataset

### Performance Characteristics

- **Cache locality**: Poor due to scattered node allocation
- **Memory overhead**: Significant for alphabets with many unused branches
- **Traversal cost**: Depth determines performance, not dataset size

### Advanced Variations

- **Suffix trie**: Trie of all suffixes for substring operations
- **Compressed trie (Patricia)**: Path compression to reduce nodes
- **Ternary Search Tree**: Binary-tree-like structure with better memory usage
- **Double-Array Trie**: Space-efficient implementation using two arrays

### Implementation Considerations

- **Thread safety**: Standard implementation is not thread-safe
- **Case sensitivity**: Normalize input for case-insensitive operations
- **Unicode support**: Use HashMap<Character, TrieNode> for full Unicode

</details>
