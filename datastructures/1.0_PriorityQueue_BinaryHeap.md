# Priority Queue (Binary Heap)

## Quick Definition

Complete binary tree that maintains heap property: parent nodes have higher (max-heap) or lower (min-heap) priority than children. Efficient priority-based operations.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| Insert    | **O(log n)** | O(n) |
| Poll/Remove | **O(log n)** | — |
| Peek      | **O(1)** | — |
| Heapify   | O(n) | — |

## Core Operations

```java
// Multiple implementations
PriorityQueue<Integer> minHeap = new PriorityQueue<>();                    // min-heap default
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // max-heap
PriorityQueue<String> pq = new PriorityQueue<>(Arrays.asList("c", "a", "b"));

// Custom comparator examples
PriorityQueue<int[]> intervals = new PriorityQueue<>((a, b) -> a[0] - b[0]); // sort by first element
PriorityQueue<String> byLength = new PriorityQueue<>(Comparator.comparing(String::length));

// Basic operations
minHeap.offer(10); minHeap.offer(5); minHeap.offer(15);  // insert: [5, 10, 15]
int min = minHeap.peek();    // get minimum without removing: 5
int removed = minHeap.poll(); // remove and return minimum: 5, heap: [10, 15]

// Bulk operations
List<Integer> nums = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6);
PriorityQueue<Integer> heap = new PriorityQueue<>(nums);  // heapify in O(n)

// Top-K pattern
int[] findKLargest(int[] nums, int k) {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();  // min-heap for k largest
    for (int num : nums) {
        minHeap.offer(num);
        if (minHeap.size() > k) minHeap.poll();  // keep only k elements
    }
    return minHeap.stream().mapToInt(Integer::intValue).toArray();
}

// Merge k sorted lists pattern
class ListNode { int val; ListNode next; }
PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);
// Add first node from each list, then process

// Median maintenance with two heaps
class MedianFinder {
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // left half
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();                           // right half
    
    public void addNum(int num) {
        if (maxHeap.isEmpty() || num <= maxHeap.peek()) maxHeap.offer(num);
        else minHeap.offer(num);
        
        // Balance heaps
        if (maxHeap.size() - minHeap.size() > 1) minHeap.offer(maxHeap.poll());
        else if (minHeap.size() - maxHeap.size() > 1) maxHeap.offer(minHeap.poll());
    }
    
    public double findMedian() {
        if (maxHeap.size() == minHeap.size()) return (maxHeap.peek() + minHeap.peek()) / 2.0;
        return maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek();
    }
}
```

## Python Snippet

```python
import heapq

# Min-heap (default)
min_heap = []
for x in [10, 5, 15]:
    heapq.heappush(min_heap, x)
min_val = min_heap[0]
removed = heapq.heappop(min_heap)

# Max-heap via negation
max_heap = []
for x in [10, 5, 15]:
    heapq.heappush(max_heap, -x)
max_val = -max_heap[0]
removed_max = -heapq.heappop(max_heap)

# Top-K (k largest)
def k_largest(nums, k):
    h = []
    for num in nums:
        heapq.heappush(h, num)
        if len(h) > k:
            heapq.heappop(h)
    return h  # contains k largest (unsorted)

# Median Finder (two heaps)
class MedianFinder:
    def __init__(self):
        self.left = []   # max-heap (store negatives)
        self.right = []  # min-heap
    def add_num(self, num):
        if not self.left or num <= -self.left[0]:
            heapq.heappush(self.left, -num)
        else:
            heapq.heappush(self.right, num)
        # balance
        if len(self.left) > len(self.right) + 1:
            heapq.heappush(self.right, -heapq.heappop(self.left))
        if len(self.right) > len(self.left) + 1:
            heapq.heappush(self.left, -heapq.heappop(self.right))
    def find_median(self):
        if len(self.left) == len(self.right):
            return (-self.left[0] + self.right[0]) / 2.0
        return -self.left[0] if len(self.left) > len(self.right) else self.right[0]
```

## When to Use

- Task scheduling systems with priorities
- Dijkstra's shortest path algorithm
- A* pathfinding with heuristic costs
- Operating system process scheduling
- Real-time streaming algorithms (median, top-k)

## Trade-offs

**Pros:**

- O(log n) insertion and deletion
- O(1) access to highest priority element
- Space-efficient array-based implementation
- Excellent for streaming algorithms

**Cons:**

- No efficient search for arbitrary elements
- Not suitable for frequent priority updates
- No inherent ordering except for root
- Requires custom comparator for complex priorities

## Practice Problems

- **Kth Largest Element**: Use min-heap of size k
- **Merge k Sorted Lists**: Priority queue with list heads
- **Find Median from Data Stream**: Two heaps (max for left, min for right)
- **Top K Frequent Elements**: Frequency map + min-heap
- **Meeting Rooms II**: Min-heap for room scheduling

<details>
<summary>Implementation Notes (Advanced)</summary>

### Heap Implementation

- **Array representation**: Parent at i/2, children at 2i and 2i+1
- **Complete binary tree**: All levels filled except possibly last (left-to-right)
- **Heap property**: Parent ≥ children (max-heap) or parent ≤ children (min-heap)

### Operations Details

- **Insertion**: Add to end, bubble up (swim) to maintain heap property
- **Deletion**: Replace root with last element, bubble down (sink)
- **Heapify**: Build heap from array in O(n) time using bottom-up approach

### Performance Characteristics

- **Cache friendly**: Array-based storage improves locality
- **Space overhead**: Minimal, just array storage
- **Stability**: Not stable by default (equal elements may be reordered)

### Advanced Variations

- **d-ary heap**: Each node has d children instead of 2
- **Fibonacci heap**: Better amortized bounds for decrease-key operations
- **Binomial heap**: Supports efficient merging of heaps

</details>
