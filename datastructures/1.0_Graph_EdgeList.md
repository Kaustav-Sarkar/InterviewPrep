# Graph Edge List

## Quick Definition

Graph representation as a simple list of edges. Each edge typically stored as pair/triple (source, destination, weight). Minimal space overhead and good for edge-centric algorithms.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| Add Edge | **O(1)** | O(E) |
| Remove Edge | O(E) | — |
| Check Edge | O(E) | — |
| Get Neighbors | O(E) | — |
| Sort Edges | O(E log E) | — |

## Core Operations

```java
// Simple edge representation
class Edge {
    int from, to, weight;
    Edge(int from, int to, int weight) {
        this.from = from; this.to = to; this.weight = weight;
    }
    Edge(int from, int to) { this(from, to, 1); }  // unweighted
}

// Edge list graph
class GraphEdgeList {
    List<Edge> edges = new ArrayList<>();
    int vertices;
    
    public GraphEdgeList(int vertices) { this.vertices = vertices; }
    
    public void addEdge(int from, int to, int weight) {
        edges.add(new Edge(from, to, weight));
    }
    
    public void addUndirectedEdge(int u, int v, int weight) {
        edges.add(new Edge(u, v, weight));
        edges.add(new Edge(v, u, weight));
    }
    
    public List<Edge> getEdges() { return edges; }
    
    public void sortByWeight() {
        edges.sort(Comparator.comparingInt(e -> e.weight));
    }
}

// Alternative: using int arrays for edges
List<int[]> edgeList = new ArrayList<>();
edgeList.add(new int[]{0, 1, 10});  // from=0, to=1, weight=10
edgeList.add(new int[]{1, 2, 5});   // from=1, to=2, weight=5

// Kruskal's MST algorithm (perfect for edge list)
class UnionFind {
    int[] parent, rank;
    UnionFind(int n) {
        parent = new int[n]; rank = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    int find(int x) {
        if (parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }
    boolean union(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) return false;
        if (rank[px] < rank[py]) { int temp = px; px = py; py = temp; }
        parent[py] = px;
        if (rank[px] == rank[py]) rank[px]++;
        return true;
    }
}

List<Edge> kruskalMST(GraphEdgeList graph) {
    List<Edge> mst = new ArrayList<>();
    UnionFind uf = new UnionFind(graph.vertices);
    
    // Sort edges by weight
    graph.sortByWeight();
    
    for (Edge edge : graph.getEdges()) {
        if (uf.union(edge.from, edge.to)) {
            mst.add(edge);
            if (mst.size() == graph.vertices - 1) break;
        }
    }
    return mst;
}

// Bellman-Ford shortest path (works well with edge list)
Map<Integer, Integer> bellmanFord(List<Edge> edges, int vertices, int source) {
    Map<Integer, Integer> dist = new HashMap<>();
    
    // Initialize distances
    for (int i = 0; i < vertices; i++) {
        dist.put(i, i == source ? 0 : Integer.MAX_VALUE);
    }
    
    // Relax edges V-1 times
    for (int i = 0; i < vertices - 1; i++) {
        for (Edge edge : edges) {
            if (dist.get(edge.from) != Integer.MAX_VALUE) {
                int newDist = dist.get(edge.from) + edge.weight;
                if (newDist < dist.get(edge.to)) {
                    dist.put(edge.to, newDist);
                }
            }
        }
    }
    
    // Check for negative cycles
    for (Edge edge : edges) {
        if (dist.get(edge.from) != Integer.MAX_VALUE &&
            dist.get(edge.from) + edge.weight < dist.get(edge.to)) {
            throw new RuntimeException("Negative cycle detected");
        }
    }
    return dist;
}

// Convert edge list to adjacency list
Map<Integer, List<Integer>> toAdjacencyList(List<Edge> edges) {
    Map<Integer, List<Integer>> adjList = new HashMap<>();
    for (Edge edge : edges) {
        adjList.computeIfAbsent(edge.from, k -> new ArrayList<>()).add(edge.to);
    }
    return adjList;
}
```

## Python Snippet

```python
# Edge as tuple: (from, to, weight)
edges = [(0, 1, 10), (1, 2, 5)]

# Kruskal's MST
class UnionFind:
    def __init__(self, n):
        self.p = list(range(n)); self.r = [0]*n
    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]
    def union(self, a, b):
        ra, rb = self.find(a), self.find(b)
        if ra == rb: return False
        if self.r[ra] < self.r[rb]: ra, rb = rb, ra
        self.p[rb] = ra
        if self.r[ra] == self.r[rb]: self.r[ra] += 1
        return True

def kruskal_mst(edges, n):
    uf = UnionFind(n)
    mst = []
    for u, v, w in sorted(edges, key=lambda e: e[2]):
        if uf.union(u, v):
            mst.append((u, v, w))
            if len(mst) == n - 1: break
    return mst

# Bellman-Ford
def bellman_ford(edges, n, s):
    INF = 10**15
    dist = [INF]*n
    dist[s] = 0
    for _ in range(n-1):
        updated = False
        for u, v, w in edges:
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w; updated = True
        if not updated: break
    for u, v, w in edges:
        if dist[u] + w < dist[v]:
            raise ValueError("Negative cycle")
    return dist
```

## When to Use

- Minimum Spanning Tree algorithms (Kruskal's)
- Sorting edges by weight for greedy algorithms
- Bellman-Ford shortest path with negative weights
- Simple graph storage and serialization
- Converting between different graph representations

## Trade-offs

**Pros:**

- Minimal memory overhead O(E)
- Excellent for edge-centric algorithms
- Easy to sort edges by various criteria
- Simple serialization format
- Good for sparse graphs

**Cons:**

- O(E) time for neighbor queries
- Inefficient for vertex-centric operations
- No fast edge existence checking
- Poor for graph traversal algorithms

## Practice Problems

- **Minimum Spanning Tree**: Use Kruskal's algorithm with edge list
- **Network Delay Time**: Bellman-Ford or convert to adjacency list
- **Cheapest Flights Within K Stops**: Modified Bellman-Ford
- **Find Critical and Pseudo-Critical Edges**: MST with edge filtering
- **Swim in Rising Water**: Convert grid to edge list, find MST

<details>
<summary>Implementation Notes (Advanced)</summary>

### Edge Representation Choices

- **Custom Edge class**: Type-safe, readable, slight overhead
- **int[] arrays**: Memory-efficient, requires careful indexing
- **Tuples/Records**: Modern Java records provide clean syntax
- **Parallel arrays**: Separate arrays for from, to, weight

### Memory Efficiency

- **Struct of arrays vs Array of structs**: Better cache locality
- **Primitive collections**: Avoid boxing overhead for large graphs
- **Edge compression**: Pack multiple fields into single long

### Algorithm Suitability

- **MST algorithms**: Excellent for Kruskal's, poor for Prim's
- **Shortest path**: Good for Bellman-Ford, poor for Dijkstra
- **Graph traversal**: Convert to adjacency representation first
- **Connectivity**: Works well with Union-Find data structure

### Performance Considerations

- **Sorting overhead**: O(E log E) for weight-based algorithms
- **Linear scans**: Most operations require full edge list traversal
- **Cache behavior**: Good locality for sequential edge processing

</details>
