# Linked List (Doubly)

## Quick Definition

Linear data structure where each node contains data plus pointers to both next and previous nodes, enabling bidirectional traversal.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| Access    | O(n) | O(n) |
| Search    | O(n) | — |
| Insert    | O(1)* | — |
| Delete    | O(1)* | — |
*O(1) if node reference known, O(n) to find position

## Core Operations

```java
// Using Java's LinkedList (implements doubly linked list)
LinkedList<Integer> list = new LinkedList<>();
LinkedList<String> words = new LinkedList<>(Arrays.asList("a", "b", "c"));

// Head and tail operations (O(1))
list.addFirst(10);      // insert at head: [10]
list.addLast(20);       // insert at tail: [10, 20]
list.add(30);           // same as addLast: [10, 20, 30]

int head = list.removeFirst();  // remove from head: 10, list: [20, 30]
int tail = list.removeLast();   // remove from tail: 30, list: [20]

// Positional operations
list.add(1, 25);        // insert at index 1: [20, 25]
int val = list.get(0);  // access by index: 20 (O(n/2) average)
list.set(1, 35);        // update at index: [20, 35]

// Bidirectional iteration
Iterator<Integer> forward = list.iterator();
Iterator<Integer> backward = list.descendingIterator();
while (backward.hasNext()) System.out.print(backward.next() + " ");

// Custom doubly linked node
class DoublyNode {
    int val;
    DoublyNode prev, next;
    DoublyNode(int val) { this.val = val; }
}

// Manual implementation patterns
void insertAfter(DoublyNode node, int val) {
    DoublyNode newNode = new DoublyNode(val);
    newNode.next = node.next;
    newNode.prev = node;
    if (node.next != null) node.next.prev = newNode;
    node.next = newNode;
}

void deleteNode(DoublyNode node) {
    if (node.prev != null) node.prev.next = node.next;
    if (node.next != null) node.next.prev = node.prev;
}

// LRU Cache pattern using doubly linked list
class LRUNode {
    int key, value;
    LRUNode prev, next;
    LRUNode(int key, int value) { this.key = key; this.value = value; }
}
```

## Python Snippet

```python
from collections import deque

# Using deque (doubly-linked) for typical operations
dq = deque(["a", "b", "c"])  # add/remove both ends in O(1)
dq.appendleft("x"); dq.append("y")
left = dq.popleft(); right = dq.pop()

# Manual doubly linked node
class DoublyNode:
    def __init__(self, val):
        self.val = val
        self.prev = None
        self.next = None

def insert_after(node, val):
    new = DoublyNode(val)
    new.next = node.next
    new.prev = node
    if node.next: node.next.prev = new
    node.next = new

def delete_node(node):
    if node.prev: node.prev.next = node.next
    if node.next: node.next.prev = node.prev
```

## When to Use

- LRU/LFU cache implementations (efficient node removal)
- Browser history with back/forward navigation
- Undo/redo functionality in applications
- Music/video playlist with bidirectional navigation
- Text editors for cursor movement and editing

## Trade-offs

**Pros:**

- O(1) insertion/deletion at both ends
- Bidirectional traversal capabilities
- O(1) node removal when node reference available
- No array shifting overhead for middle operations

**Cons:**

- Higher memory overhead (extra prev pointer per node)
- More complex pointer management than singly linked
- Poor cache locality due to non-contiguous memory
- O(n) access by index (though O(n/2) from either end)

## Practice Problems

- **LRU Cache**: Implement using HashMap + doubly linked list
- **Flatten Multilevel Doubly Linked List**: Handle child pointers
- **Remove Zero Sum Consecutive Nodes**: Use prefix sum technique
- **Design Browser History**: Back/forward navigation with doubly linked list
- **All O(1) Data Structure**: Support insert, delete, getRandom in O(1)

<details>
<summary>Implementation Notes (Advanced)</summary>

### Memory Layout

- **Node overhead**: Each node stores data + 2 pointers (16-24 bytes)
- **LinkedList**: Java's implementation includes size tracking and modCount
- **Cache performance**: Poor due to pointer chasing, but better than general tree structures

### Implementation Details

- **Sentinel nodes**: Many implementations use dummy head/tail for simpler logic
- **Circular vs linear**: Circular variants where tail.next = head, head.prev = tail
- **Thread safety**: Java's LinkedList is not thread-safe

### Optimization Techniques

- **Bidirectional search**: Access by index searches from nearest end (head or tail)
- **Node recycling**: Reuse node objects to reduce garbage collection
- **Batch operations**: Process multiple elements together when possible

### Common Patterns

- **Splice operations**: Move subsequences between lists efficiently
- **Cache implementations**: Doubly linked enables O(1) LRU operations
- **Deque simulation**: Use as double-ended queue with efficient end operations

</details>
