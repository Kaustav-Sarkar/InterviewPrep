# Binary Tree (Generic)

## Quick Definition

A hierarchical data structure where each node has at most two children (left and right). No ordering constraint; serves as foundation for specialized trees.

## Big-O Summary

| Operation | Average | Worst | Space |
|-----------|---------|-------|-------|
| Search    | O(n) | O(n) | O(n) |
| Insert    | O(1)* | O(1)* | — |
| Delete    | O(n) | O(n) | — |
| Traversal | O(n) | O(n) | O(h)* |
*Insert O(1) if position known; h = height for recursion

## Core Operations

```java
// Custom node definition
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val; this.left = left; this.right = right;
    }
}

// Tree construction
TreeNode root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);

// Recursive traversals
void inorder(TreeNode node) {
    if (node != null) { inorder(node.left); visit(node); inorder(node.right); }
}
void preorder(TreeNode node) {
    if (node != null) { visit(node); preorder(node.left); preorder(node.right); }
}
void postorder(TreeNode node) {
    if (node != null) { postorder(node.left); postorder(node.right); visit(node); }
}

// Level-order (BFS) traversal
Queue<TreeNode> queue = new LinkedList<>();
queue.offer(root);
while (!queue.isEmpty()) {
    TreeNode current = queue.poll();
    visit(current);
    if (current.left != null) queue.offer(current.left);
    if (current.right != null) queue.offer(current.right);
}

// Tree properties
int height = maxDepth(root);    // longest path from root to leaf
int diameter = treeDiameter(root);  // longest path between any two nodes
```

## Python Snippet

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val, self.left, self.right = val, left, right

def inorder(node, out):
    if node:
        inorder(node.left, out); out.append(node.val); inorder(node.right, out)

def preorder(node, out):
    if node:
        out.append(node.val); preorder(node.left, out); preorder(node.right, out)

def postorder(node, out):
    if node:
        postorder(node.left, out); postorder(node.right, out); out.append(node.val)

from collections import deque
def level_order(root):
    if not root: return []
    q, res = deque([root]), []
    while q:
        node = q.popleft(); res.append(node.val)
        if node.left: q.append(node.left)
        if node.right: q.append(node.right)
    return res
```

## When to Use

- Expression trees in compilers (parse trees, syntax trees)
- Decision trees in machine learning and game AI
- File system hierarchies and organizational structures
- Huffman coding trees for data compression
- Base structure for heaps, BSTs, tries, and segment trees

## Trade-offs

**Pros:**

- Flexible hierarchical representation
- Natural recursive structure for divide-and-conquer algorithms
- O(log n) height for balanced trees enables efficient operations
- Intuitive for representing nested/hierarchical relationships

**Cons:**

- No inherent ordering (unlike BST) - O(n) search
- Poor cache locality due to pointer-based structure
- Memory overhead for storing child pointers
- Risk of degenerating into linked list (unbalanced)

## Practice Problems

- **Maximum Depth**: Find height/depth of binary tree
- **Symmetric Tree**: Check if tree is mirror image of itself
- **Path Sum**: Check if root-to-leaf path exists with given sum
- **Level Order Traversal**: Return nodes level by level (BFS)
- **Diameter of Binary Tree**: Find longest path between any two nodes

<details>
<summary>Implementation Notes (Advanced)</summary>

### Traversal Strategies

- **Recursive**: Simple but uses O(h) stack space
- **Iterative**: Uses explicit stack, easier to control
- **Morris**: O(1) space using threading, modifies tree temporarily

### Tree Properties

- **Height**: Maximum depth from root to any leaf
- **Diameter**: Longest path between any two nodes (may not pass through root)
- **Balance factor**: Height difference between left and right subtrees

### Memory Considerations

- **Node size**: Typically 16-24 bytes (value + 2 pointers + padding)
- **Cache performance**: Poor due to non-contiguous memory layout
- **Memory fragmentation**: Frequent allocation/deallocation can fragment heap

### Common Patterns

- **Recursive template**: Base case + recursive calls on children
- **Level-order processing**: Use queue for BFS traversal
- **Path tracking**: Pass path state down recursive calls

</details>
