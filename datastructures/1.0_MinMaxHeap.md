# Min Max Heap

## Quick Definition

Specialized heap where both minimum and maximum elements can be accessed in O(1) time. Combines min-heap and max-heap operations efficiently.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| GetMin    | **O(1)** | O(n) |
| GetMax    | **O(1)** | — |
| Insert    | **O(log n)** | — |
| DeleteMin/Max | **O(log n)** | — |

## Core Operations

```java
// Using two PriorityQueues approach
class MinMaxHeap {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();                    // min elements
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // max elements
    
    public void insert(int val) {
        minHeap.offer(val);
        maxHeap.offer(val);
    }
    
    public int getMin() { return minHeap.peek(); }
    public int getMax() { return maxHeap.peek(); }
    public int deleteMin() { int min = minHeap.poll(); maxHeap.remove(min); return min; }
    public int deleteMax() { int max = maxHeap.poll(); minHeap.remove(max); return max; }
}

// Alternative: Using TreeSet for ordered data
TreeSet<Integer> sortedSet = new TreeSet<>();
sortedSet.add(10); sortedSet.add(5); sortedSet.add(15);
int min = sortedSet.first();   // O(log n) access
int max = sortedSet.last();    // O(log n) access

// Custom comparator examples
PriorityQueue<String> minByLength = new PriorityQueue<>(Comparator.comparing(String::length));
PriorityQueue<String> maxByLength = new PriorityQueue<>(Comparator.comparing(String::length).reversed());

// Interval scheduling with min/max priority
class Event { int time, priority; }
PriorityQueue<Event> minTime = new PriorityQueue<>((a, b) -> a.time - b.time);
PriorityQueue<Event> maxPriority = new PriorityQueue<>((a, b) -> b.priority - a.priority);

// Find median using min-max approach
class MedianTracker {
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // left half
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();                           // right half
    
    public void add(int num) {
        if (maxHeap.isEmpty() || num <= maxHeap.peek()) maxHeap.offer(num);
        else minHeap.offer(num);
        
        // Balance heaps to maintain size constraint
        if (maxHeap.size() - minHeap.size() > 1) minHeap.offer(maxHeap.poll());
        else if (minHeap.size() - maxHeap.size() > 1) maxHeap.offer(minHeap.poll());
    }
    
    public double median() {
        if (maxHeap.size() == minHeap.size()) return (maxHeap.peek() + minHeap.peek()) / 2.0;
        return maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek();
    }
}

// Running statistics tracker
class RunningStats {
    TreeSet<Integer> data = new TreeSet<>();
    
    public void add(int val) { data.add(val); }
    public int min() { return data.first(); }
    public int max() { return data.last(); }
    public int range() { return max() - min(); }
}
```

## Python Snippet

```python
import heapq

class MinMaxHeap:
    def __init__(self):
        self.min_h = []
        self.max_h = []  # store negatives for max-heap
        self.counts = {}
    def _inc(self, x, d):
        self.counts[x] = self.counts.get(x, 0) + d
        if self.counts[x] == 0:
            del self.counts[x]
    def insert(self, x):
        heapq.heappush(self.min_h, x)
        heapq.heappush(self.max_h, -x)
        self._inc(x, 1)
    def _clean_min(self):
        while self.min_h and self.min_h[0] not in self.counts:
            heapq.heappop(self.min_h)
    def _clean_max(self):
        while self.max_h and -self.max_h[0] not in self.counts:
            heapq.heappop(self.max_h)
    def get_min(self):
        self._clean_min(); return self.min_h[0]
    def get_max(self):
        self._clean_max(); return -self.max_h[0]
    def delete_min(self):
        self._clean_min(); x = heapq.heappop(self.min_h)
        self._inc(x, -1); return x
    def delete_max(self):
        self._clean_max(); x = -heapq.heappop(self.max_h)
        self._inc(x, -1); return x
```

## When to Use

- Real-time statistics tracking (min, max, median)
- Sliding window algorithms requiring both extremes
- Load balancing systems tracking min/max server loads
- Financial systems monitoring price ranges
- Game engines tracking performance metrics (min/max FPS)

## Trade-offs

**Pros:**

- O(1) access to both minimum and maximum
- Efficient for streaming data analysis
- Natural fit for range queries and statistics
- Can maintain sorted order with TreeSet

**Cons:**

- Higher memory overhead (duplicate storage or complex structure)
- Delete operations can be O(n) with dual-heap approach
- More complex implementation than single heap
- TreeSet alternative has O(log n) access instead of O(1)

## Practice Problems

- **Find Median from Data Stream**: Use min-max heap configuration
- **Sliding Window Maximum/Minimum**: Track both extremes efficiently
- **Running Statistics**: Maintain min, max, and range in real-time
- **Top K and Bottom K**: Find both highest and lowest priority items
- **Range Sum Queries**: Use min-max for boundary validation

<details>
<summary>Implementation Notes (Advanced)</summary>

### Dual-Heap Implementation

- **Memory overhead**: Stores each element twice (min-heap and max-heap)
- **Delete complexity**: O(n) for arbitrary element removal from PriorityQueue
- **Synchronization**: Must keep both heaps consistent

### TreeSet Alternative

- **Balanced complexity**: O(log n) for all operations but sorted access
- **Memory efficient**: Single storage per element
- **Range operations**: Natural support for subSet, headSet, tailSet

### Min-Max Heap Structure

- **Alternating levels**: Min levels and max levels alternate in tree
- **Complex maintenance**: Requires careful level tracking
- **Better theoretical bounds**: True O(1) min/max access

### Performance Considerations

- **Dual-heap**: Best for frequent min/max access, rare deletes
- **TreeSet**: Best for balanced access patterns and range queries
- **Custom structure**: Worth implementing for high-performance scenarios

</details>
