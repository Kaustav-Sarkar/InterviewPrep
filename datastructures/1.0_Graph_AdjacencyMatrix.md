# Graph Adjacency Matrix

## Quick Definition

Graph representation using 2D array where matrix[i][j] indicates presence (and weight) of edge from vertex i to vertex j. Efficient for dense graphs and edge queries.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| Add Edge | **O(1)** | O(V²) |
| Remove Edge | **O(1)** | — |
| Check Edge | **O(1)** | — |
| Get Neighbors | O(V) | — |
| Add Vertex | O(V²) | — |

## Core Operations

```java
// Boolean adjacency matrix (unweighted)
class GraphMatrix {
    private boolean[][] matrix;
    private int vertices;
    
    public GraphMatrix(int vertices) {
        this.vertices = vertices;
        matrix = new boolean[vertices][vertices];
    }
    
    public void addEdge(int from, int to) {
        matrix[from][to] = true;
    }
    
    public void addUndirectedEdge(int u, int v) {
        matrix[u][v] = matrix[v][u] = true;
    }
    
    public boolean hasEdge(int from, int to) {
        return matrix[from][to];
    }
    
    public List<Integer> getNeighbors(int vertex) {
        List<Integer> neighbors = new ArrayList<>();
        for (int i = 0; i < vertices; i++) {
            if (matrix[vertex][i]) neighbors.add(i);
        }
        return neighbors;
    }
}

// Weighted adjacency matrix
int[][] weightedMatrix = new int[vertices][vertices];
int INF = Integer.MAX_VALUE;

// Initialize with infinity (no edge)
for (int i = 0; i < vertices; i++) {
    Arrays.fill(weightedMatrix[i], INF);
    weightedMatrix[i][i] = 0;  // distance to self is 0
}

// Add weighted edges
weightedMatrix[0][1] = 10;  // edge from 0 to 1 with weight 10
weightedMatrix[1][2] = 5;   // edge from 1 to 2 with weight 5

// Floyd-Warshall all-pairs shortest path
void floydWarshall(int[][] dist) {
    int n = dist.length;
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}

// Matrix multiplication for path counting
int[][] multiplyMatrices(int[][] A, int[][] B) {
    int n = A.length;
    int[][] C = new int[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < n; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    return C;
}

// Transitive closure (reachability)
boolean[][] transitiveClosure(boolean[][] graph) {
    int n = graph.length;
    boolean[][] reach = new boolean[n][n];
    
    // Copy original graph
    for (int i = 0; i < n; i++) {
        System.arraycopy(graph[i], 0, reach[i], 0, n);
    }
    
    // Floyd-Warshall for reachability
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                reach[i][j] = reach[i][j] || (reach[i][k] && reach[k][j]);
            }
        }
    }
    return reach;
}
```

## Python Snippet

```python
# Boolean adjacency matrix
class GraphMatrix:
    def __init__(self, n):
        self.n = n
        self.mat = [[False]*n for _ in range(n)]
    def add_edge(self, u, v):
        self.mat[u][v] = True
    def add_undirected(self, u, v):
        self.mat[u][v] = self.mat[v][u] = True
    def has_edge(self, u, v):
        return self.mat[u][v]
    def neighbors(self, u):
        return [i for i, ok in enumerate(self.mat[u]) if ok]

# Weighted matrix and Floyd-Warshall
INF = 10**15
def floyd_warshall(dist):
    n = len(dist)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] < INF and dist[k][j] < INF:
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

# Transitive closure
def transitive_closure(graph):
    n = len(graph)
    reach = [row[:] for row in graph]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                reach[i][j] = reach[i][j] or (reach[i][k] and reach[k][j])
    return reach
```

## When to Use

- Dense graphs where most vertex pairs are connected
- Frequent edge existence queries O(1)
- Mathematical graph operations (matrix multiplication)
- All-pairs shortest path algorithms (Floyd-Warshall)
- Small graphs where O(V²) space is acceptable

## Trade-offs

**Pros:**

- O(1) edge addition, removal, and lookup
- Excellent for dense graphs
- Simple implementation and intuitive representation
- Efficient for mathematical operations on graphs

**Cons:**

- O(V²) space regardless of edge count
- Inefficient for sparse graphs
- Adding vertices requires matrix resize O(V²)
- Poor cache performance for large matrices

## Practice Problems

- **Find the Town Judge**: Count in-degrees and out-degrees using matrix
- **Shortest Path in Binary Matrix**: BFS on implicit adjacency matrix
- **Network Delay Time**: Single-source shortest path with matrix
- **Course Schedule**: Cycle detection using matrix representation
- **Redundant Connection**: Union-find on matrix-represented graph

<details>
<summary>Implementation Notes (Advanced)</summary>

### Memory Layout

- **Row-major order**: Elements stored consecutively by rows
- **Cache locality**: Better for row-wise access patterns
- **Bit packing**: Use BitSet for unweighted graphs to save memory

### Space Optimizations

- **Symmetric matrices**: Store only upper triangle for undirected graphs
- **Sparse representation**: Switch to adjacency list when density < threshold
- **Compressed formats**: CSR/CSC for static sparse matrices

### Performance Characteristics

- **Dense graphs**: Matrix wins when edges > V²/8 approximately
- **Cache behavior**: Good locality for algorithms with nested loops
- **Parallelization**: Matrix operations parallelize well

### Mathematical Properties

- **Matrix powers**: A^k gives path counts of length k
- **Eigenvalues**: Spectral properties reveal graph structure
- **Determinant**: Related to spanning tree count (matrix-tree theorem)

</details>
