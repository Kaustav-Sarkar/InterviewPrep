# Linked List (Singly)

## Quick Definition

Linear data structure where elements (nodes) are connected via pointers, with each node containing data and reference to the next node.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| Access    | O(n) | O(n) |
| Search    | O(n) | — |
| Insert    | O(1)* | — |
| Delete    | O(1)* | — |
*O(1) if position/reference known, O(n) to find position

## Core Operations

```java
// Custom node definition
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

// List construction
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);

// Insertion at head (O(1))
ListNode newHead = new ListNode(0);
newHead.next = head;
head = newHead;

// Insertion after node (O(1) if node reference available)
void insertAfter(ListNode node, int val) {
    ListNode newNode = new ListNode(val);
    newNode.next = node.next;
    node.next = newNode;
}

// Deletion (O(1) with previous node reference)
void deleteAfter(ListNode node) {
    if (node.next != null) {
        node.next = node.next.next;
    }
}

// Traversal patterns
void printList(ListNode head) {
    ListNode current = head;
    while (current != null) {
        System.out.print(current.val + " ");
        current = current.next;
    }
}

// Two-pointer technique (fast/slow)
ListNode findMiddle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;  // middle node
}

// Reverse iteratively
ListNode reverse(ListNode head) {
    ListNode prev = null, current = head;
    while (current != null) {
        ListNode next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    return prev;  // new head
}
```

## Python Snippet

```python
# Node definition
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# Insert at head
head = ListNode(1, ListNode(2, ListNode(3)))
head = ListNode(0, head)

# Insert after node (O(1) with reference)
def insert_after(node, val):
    node.next = ListNode(val, node.next)

# Delete after node
def delete_after(node):
    if node and node.next:
        node.next = node.next.next

# Reverse iteratively
def reverse(head):
    prev, curr = None, head
    while curr:
        nxt = curr.next
        curr.next = prev
        prev, curr = curr, nxt
    return prev
```

## When to Use

- Dynamic size requirements with frequent insertions/deletions
- Memory-constrained environments (no pre-allocation needed)
- Implementing stacks, queues, and other linear structures
- Building more complex structures (adjacency lists, hash table chaining)
- When array size is unpredictable or highly variable

## Trade-offs

**Pros:**

- Dynamic sizing - no memory pre-allocation
- O(1) insertion/deletion at known positions
- Memory-efficient for sparse data
- Easy to split, merge, and rearrange

**Cons:**

- O(n) random access (no indexing)
- Poor cache locality due to non-contiguous memory
- Extra memory overhead for storing pointers
- No backward traversal (use doubly linked for that)

## Practice Problems

- **Reverse Linked List**: Reverse pointers iteratively or recursively
- **Merge Two Sorted Lists**: Merge while maintaining sorted order
- **Linked List Cycle**: Detect cycle using Floyd's algorithm
- **Remove Nth from End**: Use two-pointer technique with gap
- **Palindrome Linked List**: Find middle, reverse second half, compare

<details>
<summary>Implementation Notes (Advanced)</summary>

### Memory Layout

- **Node overhead**: Each node stores data + 1 pointer (8-16 bytes overhead)
- **Cache performance**: Poor due to scattered memory allocation
- **Memory fragmentation**: Frequent allocation/deallocation can fragment heap

### Pointer Manipulation Patterns

- **Dummy head**: Simplifies edge cases for insertion/deletion
- **Two pointers**: Fast/slow for middle finding, cycle detection
- **Previous tracking**: Keep reference to previous node for deletion

### Common Algorithms

- **Floyd's cycle detection**: Fast/slow pointers to detect cycles
- **Reverse in groups**: Reverse k nodes at a time
- **Merge technique**: Dummy head simplifies merging logic

### Performance Considerations

- **Sequential access**: Much faster than random access
- **Memory allocation**: Consider object pooling for high-frequency operations
- **Stack overflow**: Deep recursion on long lists can cause issues

</details>
