# Stack

## Quick Definition

LIFO (Last In, First Out) data structure where elements are added and removed from the same end (top). Think of a stack of plates.

## Big-O Summary

| Operation | Time | Space |
|-----------|------|-------|
| Push      | **O(1)** | O(n) |
| Pop       | **O(1)** | — |
| Peek/Top  | **O(1)** | — |
| Search    | O(n) | — |

## Core Operations

```java
// Multiple implementation options
Stack<Integer> stack1 = new Stack<>();           // legacy, synchronized
ArrayDeque<Integer> stack2 = new ArrayDeque<>(); // preferred
ArrayList<Integer> stack3 = new ArrayList<>();   // manual implementation

// Push operations  
stack2.push(10); stack2.push(20); stack2.push(30);
// Alternative: stack2.addLast(), stack3.add()

// Pop operations
int top = stack2.pop();          // removes and returns: 30
int peek = stack2.peek();        // returns without removing: 20
// Alternative: stack2.removeLast(), stack3.remove(stack3.size()-1)

// Check state
boolean empty = stack2.isEmpty();
int size = stack2.size();

// Multiple element operations
stack2.addAll(Arrays.asList(40, 50, 60));  // push multiple
while (!stack2.isEmpty()) {
    System.out.println(stack2.pop());       // print in reverse order
}

// Custom min-stack implementation
class MinStack {
    ArrayDeque<Integer> stack = new ArrayDeque<>();
    ArrayDeque<Integer> minStack = new ArrayDeque<>();
    
    void push(int x) {
        stack.push(x);
        if (minStack.isEmpty() || x <= minStack.peek()) minStack.push(x);
    }
    int getMin() { return minStack.peek(); }  // O(1) min access
}
```

## Python Snippet

```python
from collections import deque

# Multiple implementation options
stack1 = []                # list
stack2 = deque()           # preferred

# Push / Pop
stack2.append(10); stack2.append(20); stack2.append(30)
top = stack2.pop()         # 30
peek = stack2[-1]          # 20

# Custom MinStack
class MinStack:
    def __init__(self): self.s = []; self.m = []
    def push(self, x):
        self.s.append(x)
        self.m.append(x if not self.m else min(x, self.m[-1]))
    def pop(self):
        self.m.pop(); return self.s.pop()
    def get_min(self):
        return self.m[-1]
```

## When to Use

- Function call management (call stack in programming languages)
- Expression evaluation and syntax parsing (parentheses matching)
- Undo operations in text editors and applications
- Backtracking algorithms (DFS, maze solving)
- Browser back button functionality and navigation history

## Trade-offs

**Pros:**

- O(1) push, pop, and peek operations
- Simple and intuitive LIFO semantics
- Efficient memory usage (no random access overhead)
- Natural fit for recursive algorithm conversion

**Cons:**

- No random access to middle elements
- Limited to LIFO access pattern only
- Stack overflow risk with deep recursion
- No built-in search or iteration capabilities

## Practice Problems

- **Valid Parentheses**: Check if brackets/parentheses are properly matched
- **Evaluate RPN**: Calculate result of reverse polish notation expression
- **Min Stack**: Implement stack with O(1) getMin() operation
- **Largest Rectangle in Histogram**: Use monotonic stack for optimization
- **Next Greater Element**: Find next greater element for each array element

<details>
<summary>Implementation Notes (Advanced)</summary>

### Implementation Choices

- **ArrayDeque**: Preferred modern implementation, resizable array-based
- **Stack class**: Legacy, synchronized (thread-safe but slower)
- **ArrayList**: Manual implementation with add/remove at end

### Memory Management

- **Dynamic resizing**: ArrayDeque grows by 2x when full
- **Memory overhead**: ~25-50% unused capacity in dynamic implementations
- **Stack frame size**: JVM call stack typically 1MB per thread

### Performance Characteristics

- **Cache locality**: Array-based implementations have better cache performance
- **Thread safety**: Stack class is synchronized, ArrayDeque is not
- **Memory footprint**: Linked implementations have pointer overhead

### Common Patterns

- **Monotonic stack**: Maintain increasing/decreasing order for optimization
- **Auxiliary stacks**: Use additional stacks to track min/max values
- **Stack simulation**: Convert recursion to iteration using explicit stack

</details>
